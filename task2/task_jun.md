## Задание для джуна: MultiReader с асинхронным буфером (prefetch)

### Введение простыми словами

- **MultiReader**: представь, что у тебя несколько источников данных (например, несколько файлов). Мы хотим читать их как один длинный файл: сначала первый, затем второй и т.д.
- **Префетч (prefetch)**: это когда мы заранее читаем данные в память фоном, чтобы когда пользователь попросит `Read`, ответы были быстрее (данные уже под рукой в буфере). Это особенно полезно при последовательном чтении.

### Что нужно сделать

Реализовать в `task2` улучшенную версию `MultiReader`, которая:

- **Объединяет** несколько ридеров в один поток: `[]SizedReadSeekCloser -> MultiReader`.
- **Всегда читает** наружу из внутреннего буфера, который предварительно заполняется фоном.
- **Префетчит** данные последовательно вперёд, начиная с текущей позиции чтения.
- **Лениво запускает** префетч: горутина с префетчем стартует только при первом вызове `Read`, а не в конструкторе.
- **Поддерживает Seek**: если позиция внутри текущего буфера, просто двигаем «курсор». Если вне — сбрасываем буфер и переинициализируем префетч с новой позиции.
- **Корректно закрывается**: `Close` должен останавливать фоновую горутину и закрывать все исходные ридеры без утечек и с агрегацией ошибок.

Важно: не пиши «лестничный» сложный код — решение должно быть понятным, с чёткими границами ответственности у методов.

### Точки интеграции (интерфейсы и поведение)

- `SizedReadSeekCloser`: это интерфейс источника, поддерживающий `Read`, `Seek`, `Close`, и метод `Size()` c размером данных.
- `MultiReader` должен реализовать интерфейс `io.ReadSeekCloser` и иметь метод `Size()`.
- Конструктор `NewMultiReader(readers ...SizedReadSeekCloser) *MultiReader`:
  - Сохраняет ридеры, считает их суммарный размер и префиксные суммы для быстрого поиска текущего ридера по абсолютной позиции.
  - Выставляет начальные поля для буфера и синхронизации.
- `Read(p []byte) (int, error)`:
  - Всегда читает из внутреннего буфера. Если данных нет — ждёт пополнение или завершение (EOF/ошибка).
  - Если прочитали часть и дальше ошибка — вернуть сначала прочитанное, затем ошибку в следующий вызов.
  - При достижении конца общего потока возвращать `io.EOF`.
- `Seek(offset, whence)`:
  - Если новая позиция внутри текущего буферного окна — просто сдвиг «курсор».
  - Если вне окна — сбросить окно, переинициализировать префетч с новой позиции.
  - Позиции вне диапазона `[0, totalSize]` — ошибка.
- `Close() error`:
  - Остановить префетч-горутину (graceful shutdown: разбудить горутину, дождаться завершения) и закрыть все исходные ридеры.
  - Повторные вызовы `Close` — возвращают `nil`.
  - После `Close` любые `Read`/`Seek` — `io.ErrClosedPipe`.

### Ограничения и ожидания

- Один внешний потребитель (одновременных `Read` из разных горутин не будет). Но твой код должен быть аккуратным с синхронизацией.
- Не используй глобальные переменные. Экспортируемые структуры/функции — с комментариями в стиле GoDoc.
- Обрабатывай ошибки явно; не используй однострочную форму `if err := ...; err != nil`.
- Код должен быть отформатирован (`gofmt`).

### Архитектурные подсказки

- **Структура MultiReader**:
  - Данные: `readers`, `totalSize`, `prefixSizes`, `absPos`.
  - Буферное окно: `bufferStart`, `bufferData []byte`, `bufferCap`, `prefetchErr`.
  - Синхронизация: `sync.Mutex`, `*sync.Cond` (для ожидания/пробуждения между читателем и префетчером).
  - Жизненный цикл префетча: флаги `prefetchStarted`, `prefetchStopping`, канал завершения `prefetchDone`, параметры перезапуска `pfPos`, `pfNeedSeek`.
- **Буфер-окно**: считаем, что буфер покрывает диапазон `[bufferStart, bufferStart+len(bufferData))`. При чтении «съедаем» голову окна (сдвигаем `bufferStart`, уменьшаем `bufferData`).
- **Префетч-горутинa**:
  - Запускается в первом `Read`.
  - Пока есть место в буфере — читает блоки от текущей позиции вперёд; если места нет — ждёт сигнала от читателя (через `Cond`).
  - Ввод-вывод (`Seek`/`Read` нижних ридеров) выполняй без удержания мьютекса, чтобы не блокировать читателя.
  - При ошибке/EOF: сохраняй ошибку в поле и буди ожидающих.
  - Завершение: по флагу остановки/закрытия — выйти без утечек.
- **Поиск текущего ридера**: можно использовать `sort.Search` по массиву `prefixSizes` (это префиксные суммы размеров ридеров).

### Пошаговый план реализации

1. Добавь поля в `MultiReader` для буфера, синхронизации и состояния префетча.
2. В `NewMultiReader` посчитай `prefixSizes` и `totalSize`, инициализируй `Cond`, выставь вместимость буфера (например, размер блока × число блоков).
3. Напиши `startPrefetch` (внутренний метод), который запускает горутину-префетчер.
4. Напиши цикл префетчера: вычисляет, откуда читать, делает `Seek` (первый раз при старте/после `Seek` пользователя), читает блоками, добавляет в `bufferData`, будит потребителя, следит за флагами остановки.
5. В `Read` реализуй логику: читать из буфера, ждать, пока появятся данные/EOF/ошибка, корректно обрабатывать частичное чтение и `EOF`.
6. В `Seek` сначала проверь попадание в окно; если нет — сбрось окно, выставь параметры перезапуска префетча и разбуди его.
7. В `Close` аккуратно останови префетч (разбуди горутину, дождись завершения), затем закрой все ридеры; ошибки собери через `errors.Join`.
8. Проверь, что `Read/Seek` после `Close` возвращают `io.ErrClosedPipe`.
9. Пройдись по коду: нет ли гонок (особенно обращений к буферу/флагам без мьютекса), нет ли утечек горутин, корректно ли снимается блокировка на время I/O.
10. Отформатируй код и добавь однострочные GoDoc-комментарии к экспортируемым элементам.

### Критерии приёмки (готовности)

- Все тесты из папки `task2` проходят (запуск через `compile.sh` и `run.sh`).
- Поведение `Read/Seek/Close` соответствует описанию.
- Нет утечек горутин при многократных `Seek` и при `Close`.
- Ошибки и `EOF` отдаются корректно (частичное чтение не теряется).

### Типичные ошибки и как их избежать

- Держать мьютекс во время `Read`/`Seek` нижних ридеров — это может блокировать потребителя и привести к deadlock’ам. Делай I/O без мьютекса.
- Обрезать из буфера данные, которые ещё не прочитал потребитель — так теряются байты. Обрезай только «голову» до текущей позиции чтения.
- Не будить `Cond` после изменений — префетчер/читатель могут зависнуть. Всегда вызывай `Broadcast()` после добавления/потребления данных или смены флагов.
- Не останавливать горутину в `Close` — это утечка. Сделай явные флаги остановки и дождись завершения.

### Как самопровериться

- Смоделируй сценарий: небольшой буфер и большие данные — буфер много раз наполняется/опустошается, всё работает без гонок.
- Сделай `Seek` вперёд-назад: попади внутрь окна и за его пределы — корректно ли работает?
- Попробуй закрыть несколько раз: повторный `Close` должен вернуть `nil`.

### Бонус (необязательно)

- Сделать настраиваемую ёмкость буфера (например, через параметр конструктора).
- Добавить метрики: сколько данных было прочитано из буфера vs из источников, сколько перезапусков префетча.

Удачи! Если застрянешь — сформулируй вопрос: «Что я сейчас делаю? Что уже работает? Где наблюдаю неправильное поведение?» Так ментору будет проще помочь.



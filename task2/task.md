## Задание: MultiReader с асинхронным буфером (prefetch)

### Введение простыми словами

- **MultiReader**: представь, что у тебя несколько источников данных (например, несколько файлов). Мы хотим читать их как один длинный файл: сначала первый, затем второй и т.д.
- **Префетч (prefetch)**: это когда мы заранее читаем данные в память фоном, чтобы когда пользователь попросит `Read`, ответы были быстрее (данные уже под рукой в буфере). Это особенно полезно при последовательном чтении.

### Что нужно сделать

Реализовать в `task2` улучшенную версию `MultiReader`, которая:

- Объединяет несколько ридеров в один поток: `[]SizedReadSeekCloser -> MultiReader`.
- Всегда читает наружу из внутреннего буфера, который предварительно заполняется фоном.
- Префетчит данные последовательно вперёд, начиная с текущей позиции чтения.
- Лениво запускает префетч: горутина с префетчем стартует только при первом вызове `Read`, а не в конструкторе.
- Поддерживает Seek: если позиция внутри текущего буфера, просто двигаем «курсор». Если вне — сбрасываем буфер и переинициализируем префетч с новой позиции.
- Корректно закрывается: `Close` должен останавливать фоновую горутину и закрывать все исходные ридеры без утечек и с агрегацией ошибок.

### Интерфейсы и поведение

- `SizedReadSeekCloser`: это интерфейс источника, поддерживающий `Read`, `Seek`, `Close`, и метод `Size()` c размером данных.
- `MultiReader` должен реализовать интерфейс `io.ReadSeekCloser` и иметь метод `Size()`.
- Конструктор `NewMultiReader(readers ...SizedReadSeekCloser) *MultiReader`:
  - Сохраняет ридеры, считает их суммарный размер и префиксные суммы для быстрого поиска текущего ридера по абсолютной позиции.
  - Выставляет начальные поля для буфера и синхронизации.
- `Read(p []byte) (int, error)`:
  - Всегда читает из внутреннего буфера. Если данных нет — ждёт пополнение или завершение (EOF/ошибка).
  - Если прочитали часть и дальше ошибка — вернуть сначала прочитанное, затем ошибку в следующий вызов.
  - При достижении конца общего потока возвращать `io.EOF`.
- `Seek(offset, whence)`:
  - Если новая позиция внутри текущего буферного окна — просто сдвиг «курсор».
  - Если вне окна — сбросить окно, переинициализировать префетч с новой позиции.
  - Позиции вне диапазона `[0, totalSize]` — ошибка.
- `Close() error`:
  - Остановить префетч-горутину (graceful shutdown: разбудить горутину, дождаться завершения) и закрыть все исходные ридеры.
  - Повторные вызовы `Close` — возвращают `nil`.
  - После `Close` любые `Read`/`Seek` — `io.ErrClosedPipe`.

### Ограничения и ожидания

- Один внешний потребитель (одновременных `Read` из разных горутин не будет). Но твой код должен быть аккуратным с синхронизацией.

### Критерии готовности

- Все тесты из папки `task2` проходят (запуск через `compile.sh` и `run.sh`).


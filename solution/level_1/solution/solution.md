## MultiReader: краткое описание реализации

MultiReader конкатенирует несколько `SizedReadSeekCloser` в единый логический поток и сам реализует этот интерфейс.

Состояние:
- `readers`: ридеры в порядке конкатенации.
- `totalSize`: суммарный размер всех ридеров (вычисляется один раз).
- `prefixSizes`: префиксные суммы размеров; `prefixSizes[i]` — абсолютное начало i‑го ридера.
- `absPos`: абсолютная позиция в объединённом потоке.
- `needSeek`: ленивый флаг; если `true`, перед следующим чтением надо выставить позицию нижележащего ридера.

### NewMultiReader
- Сохраняет ссылки на переданные ридеры.
- Предвычисляет `prefixSizes` и `totalSize` за один проход.
- Инициализирует `absPos = 0`, `needSeek = true` (позиционируемся при первом чтении).

### Size
- Возвращает предвычисленный `totalSize` (O(1), без повторных расчётов).

### Close
- Вызывает `Close()` у всех ридеров и агрегирует ошибки через `errors.Join`.
- Возвращает обёрнутую объединённую ошибку, если хотя бы один `Close` завершился с ошибкой.

### Seek
- Рассчитывает базу по `whence` (`SeekStart` → 0; `SeekCurrent` → `absPos`; `SeekEnd` → `totalSize`).
- Вычисляет целевую позицию, проверяет границы `[0, totalSize]`.
- Обновляет `absPos` и ставит `needSeek = absPos != totalSize` (ленивое позиционирование при следующем `Read`).

### Read
- Читает последовательно в буфер `p`:
  - Ранний выход: если `absPos == totalSize` — `io.EOF`, если ещё ничего не прочитали; иначе возвращает уже прочитанное.
  - Находит активный ридер по `absPos` бинарным поиском в `prefixSizes` (`sort.Search`).
  - Если `needSeek == true`, выставляет позицию текущего ридера в локальный оффсет и сбрасывает флаг.
  - Вызывает `Read(p[n:])` у текущего ридера.
  - Обработка результата:
    - Нет ошибки и `k == 0` → возвращает прочитанное.
    - Нет ошибки и `k > 0` → продолжает чтение.
    - `io.EOF` → сдвигает `absPos` к началу следующего ридера и повторяет попытку дочитать буфер.
    - Любая другая ошибка → возвращает частично прочитанное и ошибку.

## Преимущества реализации
- Ленивая установка позиции (`needSeek`):
  - Seek выполняется только когда это действительно необходимо (после внешнего `Seek`, при переходе между ридерами, при первом чтении),
  - отсутствуют лишние системные вызовы при последовательном чтении.
- Предвычисленные размеры:
  - `Size()` — O(1) без повторных суммирований,
  - `prefixSizes` позволяют быстро (O(log n)) находить активный ридер по абсолютной позиции.
- Простое и надёжное состояние:
  - одна абсолютная позиция `absPos` вместо пары «индекс/смещение», меньше шансов рассинхронизации.
- Корректная семантика `io.Reader`:
  - поддержка коротких чтений и корректный возврат `io.EOF` только когда ничего не прочитано в текущем вызове.
- Закрытие с агрегацией ошибок:
  - возвращаются все накопленные ошибки закрытия, а не только первая.

Примечания:
- Реализация не потокобезопасна по контракту `io.Reader/io.Seeker`. Для конкурентного доступа используйте внешнюю синхронизацию.

## Сложность методов

- NewMultiReader: O(n) — один проход для `prefixSizes` и суммирования размеров.
- Size: O(1).
- Close: O(n).
- Seek: O(1) — только пересчёт абсолютной позиции и установка флага ленивого seek.
- Read: зависит от объёма читаемых данных и количества внутренних чтений. На каждое внутреннее чтение есть накладные `O(log n)` для поиска активного ридера через `sort.Search`; сам переход между ридерами O(1).

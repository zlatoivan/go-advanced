# Задание "MultiReader"

## Общее для каждого пакета

- Запуск тестов - `make t`
- Проверка сборки приложения `make build`


## Easy версия (SizedReadSeekCloser)

- Условие для кандидата - [тут](1_easy/task.md)
- Шаблон для кандидата - [тут](1_easy/task.go)
- Эталонное решение - [тут](1_easy/task_expected.go)


## Medium версия (SizedReadCloser + prefetch)

- Условие для кандидата - [тут](1_medium/task.md)
- Шаблон для кандидата - [тут](1_medium/task.go)
- Эталонное решение - [тут](1_medium/task_expected.go)


## Hard версия (SizedReadSeekCloser + prefetch)

- Условие для кандидата - [тут](3_hard/task.md)
- Шаблон для кандидата - [тут](3_hard/task.go)
- Эталонное решение - [тут](3_hard/task_expected.go)


## Идеи для улучшения

- Избежать склейки в один большой буфер: хранить окно как очередь блоков []byte и выдавать их по очереди вместо append в windowBuf, чтобы сократить копирования и перераспределения.
- Переиспользовать буферы: выделять блоки через sync.Pool вместо make на каждый toRead, чтобы снизить аллокации и давление на GC.
- Добавить проверку закрытия ридера сразу после закрытия канала данных в Read, чтобы в этом случае возвращать `io.ErrClosedPipe` вместо `io.EOF`.
- Агрегировать обработку ошибок в CLose


## Вопросы по SD

- Последовательно читаем куски или частые случайные Seek. В чем разница работы программы?
- Какой лимит ОЗУ на экземпляр мультиридера (buffersNum * bufferSize + оверхед)?
- Что делаем при заполненном окне (блокируемся/применяем таймауты)?
- Что будет при одновременном вызове Read/Seek/Close?
- Как агрегировать ошибки в Close (цикл закрытия и join ошибок)?
- Как трактуем частично прочитанные данные и ошибку (отдать байты сейчас, ошибку в следующий вызов)?
